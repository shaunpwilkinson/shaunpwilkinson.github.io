<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shaun Wilkinson on Shaun Wilkinson</title>
    <link>/</link>
    <description>Recent content in Shaun Wilkinson on Shaun Wilkinson</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2019 Shaun Wilkinson</copyright>
    <lastBuildDate>Tue, 01 Jan 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>aphid: an R package for analysis with profile hidden Markov models.</title>
      <link>/publication/bioinfo2019/</link>
      <pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/publication/bioinfo2019/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Elevated Symbiodiniaceae richness at Atauro Island (Timor-Leste): a highly biodiverse reef system.</title>
      <link>/publication/core2019/</link>
      <pubDate>Wed, 02 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/publication/core2019/</guid>
      <description></description>
    </item>
    
    <item>
      <title>The &#39;insect&#39; R package and metabarcoding pipeline</title>
      <link>/post/insect-vignette/</link>
      <pubDate>Tue, 01 Jan 2019 12:00:00 +0000</pubDate>
      
      <guid>/post/insect-vignette/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Welcome to the &lt;strong&gt;insect&lt;/strong&gt; R package, a tool for assigning taxon IDs to
amplicon libraries using &lt;strong&gt;in&lt;/strong&gt;formatic &lt;strong&gt;se&lt;/strong&gt;quence &lt;strong&gt;c&lt;/strong&gt;lassification
&lt;strong&gt;t&lt;/strong&gt;rees. The &lt;strong&gt;insect&lt;/strong&gt; learning algorithm takes a set of reference
sequences (obtained from GenBank and/or other sources) to build a
classification tree, which is then used to assign taxonomic IDs to a set
of query sequences (e.g. those generated from an NGS platform such as
Illumina MiSeq). The learning and classification functions are best
suited to computing environments with multiple processors and access to
large amounts of memory; however, most modest-sized datasets can be
processed on standard personal computers if time is available. While not
a prerequisite, &lt;strong&gt;insect&lt;/strong&gt; is designed to be used in conjunction with
the &lt;strong&gt;ape&lt;/strong&gt; package (Paradis &lt;em&gt;et al.&lt;/em&gt;, 2004; Paradis, 2012), which
features memory-efficient binary formats for DNA and amino acid
sequences (&amp;ldquo;DNAbin&amp;rdquo; and &amp;ldquo;AAbin&amp;rdquo; object types), and the &lt;strong&gt;dada2&lt;/strong&gt; package
(Callahan &lt;em&gt;et al.&lt;/em&gt;, 2016) which contains essential functions for
de-noising high-throughput sequencing data and other important
pre-processing steps.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;insect&lt;/strong&gt; package can be used to analyze environmental DNA (eDNA)
meta-barcode libraries as well as single-source NGS/Sanger amplicon
sequences.&lt;/p&gt;

&lt;p&gt;The most time-consuming and memory-intensive stage of the &lt;strong&gt;insect&lt;/strong&gt;
work-flow generally involves training the classifier. For example, the
COI classifier used in this tutorial, which was built from the &lt;a href=&#34;http://reference-midori.info/download.php&#34; target=&#34;_blank&#34;&gt;MIDORI
UNIQUE&lt;/a&gt; reference trainingset
consisting of nearly a million COI barcode sequences, took around three
days to run on a 24 x multithread. The &lt;strong&gt;insect&lt;/strong&gt; classification trees
are amplicon specific, so a unique tree is generally required for each
primer set. However, trees are already available for some of the more
commonly used barcoding primers here:&lt;/p&gt;

&lt;!-- note newlines needed between html tags and code chunk --&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Marker&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Target&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Primers&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Source&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Version&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Date&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Download&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;12S&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fish&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MiFishUF/MiFishUR (&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/26587265&#34;&gt;Miya et al 2015&lt;/a&gt;)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GenBank&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;20181111&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://www.dropbox.com/s/fv3dpvws6zjvtib/classifier.rds?dl=1&#34;&gt;RDS (9MB)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;16S&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Marine crustaceans&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Crust16S_F/Crust16S_R (&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5528208/&#34;&gt;Berry et al 2017&lt;/a&gt;)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GenBank&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;20180626&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://www.dropbox.com/s/9vl9gj3frw7ng1m/classifier.rds?dl=1&#34;&gt;RDS (7.1 MB)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;16S&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Marine fish&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fish16sF/16s2R (&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5528208/&#34;&gt;Berry et al 2017&lt;/a&gt;; &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1959119/&#34;&gt;Deagle et al 2007&lt;/a&gt;)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GenBank&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;20180627&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://www.dropbox.com/s/fvfrd46exdah037/classifier.rds?dl=1&#34;&gt;RDS (6.8MB)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;18S&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Marine eukaryotes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;18S_1F/18S_400R (&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/24023913&#34;&gt;Pochon et al 2017&lt;/a&gt;)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SILVA_132_LSUParc, GenBank&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;20180709&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://www.dropbox.com/s/rmhh1g73jtipagu/classifier.rds?dl=1&#34;&gt;RDS (11.8 MB)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;18S&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Marine eukaryotes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;18S_V4F/18S_V4R (&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/28947818&#34;&gt;Stat et al 2017&lt;/a&gt;)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GenBank&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;20180525&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://www.dropbox.com/s/s315gxuo4p24kx8/classifier.rds?dl=1&#34;&gt;RDS (11.5 MB)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;23S&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Algae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;p23SrV_f1/p23SrV_r1 (&lt;a href=&#34;https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1529-8817.2007.00341.x&#34;&gt;Sherwood &amp;amp; Presting 2007&lt;/a&gt;)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SILVA_132_LSUParc&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;20180715&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://www.dropbox.com/s/6o8cauqrlgnmwp5/classifier.rds?dl=1&#34;&gt;RDS (26.9MB)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;COI&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Metazoans&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;mlCOIintF/jgHCO2198 (&lt;a href=&#34;https://frontiersinzoology.biomedcentral.com/articles/10.1186/1742-9994-10-34&#34;&gt;Leray et al 2013&lt;/a&gt;)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Midori, GenBank&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;20181124&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://www.dropbox.com/s/dvnrhnfmo727774/classifier.rds?dl=1&#34;&gt;RDS (140 MB)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ITS2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Cnidarians and sponges&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;scl58SF/scl28SR (&lt;a href=&#34;https://www.dropbox.com/s/6hcs1goju60wqi4/README.txt?dl=1&#34;&gt;Wilkinson et al in prep&lt;/a&gt;)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GenBank&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;20180920&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://www.dropbox.com/s/f07cka6308ebk2o/classifier.rds?dl=1&#34;&gt;RDS (6.6 MB)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The insect package also includes functions for downloading, trimming and
filtering reference datasets (including a &amp;ldquo;virtual PCR&amp;rdquo; tool and an
annotation quality filter), building a hierarchical taxonomy database,
and training the classifier; however, these methods are beyond the scope
of this introductory tutorial. New classification trees and updates are
frequently added to the collection, so please feel free to suggest a
barcoding primer set with which to train a classifier and we will
endeavor to add it to the list.&lt;/p&gt;

&lt;h2 id=&#34;the-insect-learning-and-classification-algorithms&#34;&gt;The INSECT learning and classification algorithms&lt;/h2&gt;

&lt;p&gt;To learn a classification tree, a reference sequence dataset is first
obtained from GenBank and/or other sources from which barcode sequences
with accurate taxon IDs are available. These sequences are filtered to
remove any with obvious taxonomic labeling issues, and trimmed to retain
only the region of interest using the &lt;code&gt;virtualPCR&lt;/code&gt; function (sequences
that do not span the entire amplicon region are removed). the &lt;code&gt;learn&lt;/code&gt;
function then splits the training sequences into two subsets, maximizing
the dissimilarity between the two groups. A profile hidden Markov model
is then derived for each group (see Durbin et al. (1998) for a detailed
description of these models). The partitioning and model training
procedure then continues recursively, splitting the reference sequences
into smaller and smaller subsets while adding new nodes and models to
the classification tree.&lt;/p&gt;

&lt;p&gt;Once the classifier has been trained, query sequences obtained from the
specified primer set can be assigned taxonomic IDs along with
probabilistic confidence values. The classification algorithm works as
follows: starting from the root node of the classification tree, the
&lt;em&gt;likelihood&lt;/em&gt; of the query sequence (the full probability of the sequence
given a particular model) is computed for each of the models at the two
immediate child nodes using the forward algorithm (see Durbin et al.
(1998)). The competing likelihood values are then compared by computing
their Akaike weights (see Johnson and Omland, 2004). If one model is
overwhelmingly more likely to have produced the sequence than the other,
that child node is selected and the classification is updated to reflect
the lowest common taxonomic rank of the training sequences belonging to
the node.&lt;/p&gt;

&lt;p&gt;This procedure is repeated recursively, descending down the tree until
either an inconclusive result is returned from a model comparison test
(i.e. the Akaike weight is lower than a pre-defined threshold, e.g.
0.9), or a terminal leaf node is reached, at which point a species-level
ID is generally returned. The &lt;code&gt;classify&lt;/code&gt; function outputs the taxon
name, rank and ID number (i.e. NCBI taxon ID, WoRMS aphia ID, or other
identifier depending on the taxonomy database used in the training
step), along with the final Akaike weight value, which can be
interpreted as a confidence score (between 0 and 1, with values close to
1 indicating high confidence). Note that the default behavior is for the
Akaike weight to &amp;lsquo;decay&amp;rsquo; as it moves down the tree, by computing the
cumulative product of all preceding Akaike weight values. This is
perhaps an overly conservative approach, but it minimizes the chance of
mis-classifying or over-classifying the query sequences.&lt;/p&gt;

&lt;h2 id=&#34;a-worked-example&#34;&gt;A worked example&lt;/h2&gt;

&lt;p&gt;This tutorial demonstrates the &lt;strong&gt;insect&lt;/strong&gt; work-flow using an example
dataset of COI sequences derived from autonomous reef monitoring
structures (ARMS) in Ofu, American Samoa, amplified using the metazoan
COI barcoding primers mlCOIintF and jgHCO2198
(GGWACWGGWTGAACWGTWTAYCCYCC and TAIACYTCIGGRTGICCRAARAAYCA,
respectively; Leray et al. (2013)).&lt;/p&gt;

&lt;p&gt;The dataset was first de-noised and tabulated using the
&lt;a href=&#34;https://benjjneb.github.io/dada2/tutorial.html&#34; target=&#34;_blank&#34;&gt;DADA2&lt;/a&gt; pipeline, to
produce a table of chimera-free amplicon sequence variants (ASVs). The
most abundant 16 ASVs are included in the &lt;strong&gt;insect&lt;/strong&gt; package as an
example dataset (see below).&lt;/p&gt;

&lt;p&gt;If using other tools for de-noising, trimming, merging, etc, the data
can be read in using either the &lt;code&gt;readFASTA&lt;/code&gt; or &lt;code&gt;readFASTQ&lt;/code&gt; functions to
produce a &amp;ldquo;DNAbin&amp;rdquo; object compatible with the &lt;strong&gt;insect&lt;/strong&gt; classifier.&lt;/p&gt;

&lt;h3 id=&#34;loading-the-package-and-data&#34;&gt;Loading the package and data&lt;/h3&gt;

&lt;p&gt;First, make sure that the &lt;strong&gt;devtools&lt;/strong&gt;, &lt;strong&gt;ape&lt;/strong&gt; and &lt;strong&gt;seqinr&lt;/strong&gt; packages
are installed and up to date. Then install and load the latest
development version of the &lt;strong&gt;insect&lt;/strong&gt; package from GitHub as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;devtools::install_github(&amp;quot;shaunpwilkinson/insect&amp;quot;)
library(insect)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The COI classifier was trained on the &lt;a href=&#34;http://reference-midori.info/download.php&#34; target=&#34;_blank&#34;&gt;MIDORI UNIQUE
20180221&lt;/a&gt; dataset, and uses
information from both the DNA read and the translated amino acid
sequence (&lt;a href=&#34;https://www.ebi.ac.uk/ena/browse/translation-tables&#34; target=&#34;_blank&#34;&gt;EBI5&lt;/a&gt;
invertebrate mitochondrial translation table) to assign taxonomy to
query sequences. You can download the classifier from the link in the
table above; the file is quite large (~ 140 MB), so make sure there is a
good internet connection available.&lt;/p&gt;

&lt;p&gt;Alternatively, the classifier can be downloaded to the current working
directory as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;download.file(&amp;quot;https://www.dropbox.com/s/dvnrhnfmo727774/classifier.rds?dl=1&amp;quot;, 
              destfile = &amp;quot;classifier.rds&amp;quot;, mode = &amp;quot;wb&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;classifying-sequences&#34;&gt;Classifying sequences&lt;/h3&gt;

&lt;p&gt;To assign taxon IDs to the table of amplicon sequence variants (ASVs)
produced by DADA2, we first extract the sequences stored as column names
in the &lt;code&gt;seqtab.nochim&lt;/code&gt; matrix (see the &lt;a href=&#34;https://benjjneb.github.io/dada2/tutorial.html&#34; target=&#34;_blank&#34;&gt;DADA2
tutorial&lt;/a&gt; for
instructions on how to produce this table).&lt;/p&gt;

&lt;p&gt;Once the sequences are stored in memory as a &amp;ldquo;DNAbin&amp;rdquo; object, we can
optionally nullify the column names in the table to avoid flooding the
console with long sequence strings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## read in the example seqtab.nochim ASV table
data(samoa)
## get sequences from table column names
x &amp;lt;- char2dna(colnames(samoa))
## name the sequences sequentially
names(x) &amp;lt;- paste0(&amp;quot;ASV&amp;quot;, seq_along(x))
## optionally remove column names that can flood the console when printed
colnames(samoa) &amp;lt;- NULL 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is to load the classifier. Note that this &amp;lsquo;insect&amp;rsquo; class
object is just a large dendrogram with additional attributes for
classifying sequences including profile HMMs and taxonomic information:&lt;/p&gt;

&lt;!-- Prior to training the classifier, the sequences were trimmed to only 
include the amplicon produced by the mlCOIintF/jgHCO2198 primers, 
and further quality filtered to include only
sequences translating to functional proteins by aligning each sequence to 
a COI profile hidden Markov model using the **aphid** R package 
(https://CRAN.R-project.org/package=aphid). --&gt;

&lt;pre&gt;&lt;code&gt;classifier &amp;lt;- readRDS(&amp;quot;classifier.rds&amp;quot;)
classifier
names(attributes(classifier))

#&amp;gt; &#39;dendrogram&#39; with 2 branches and 113833 members total, at height 70
#&amp;gt;  [1] &amp;quot;k&amp;quot;           &amp;quot;height&amp;quot;      &amp;quot;midpoint&amp;quot;    &amp;quot;members&amp;quot;     &amp;quot;class&amp;quot;      
#&amp;gt;  [6] &amp;quot;taxonomy&amp;quot;    &amp;quot;clade&amp;quot;       &amp;quot;frame&amp;quot;       &amp;quot;remainder&amp;quot;   &amp;quot;sequences&amp;quot;  
#&amp;gt; [11] &amp;quot;minscore&amp;quot;    &amp;quot;seqlengths&amp;quot;  &amp;quot;pointers&amp;quot;    &amp;quot;key&amp;quot;         &amp;quot;kmers&amp;quot;      
#&amp;gt; [16] &amp;quot;minlength&amp;quot;   &amp;quot;maxlength&amp;quot;   &amp;quot;model&amp;quot;       &amp;quot;trainingset&amp;quot; &amp;quot;alternative&amp;quot;
#&amp;gt; [21] &amp;quot;nunique&amp;quot;     &amp;quot;ntotal&amp;quot;      &amp;quot;taxID&amp;quot;       &amp;quot;numcode&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is to assign taxon IDs and confidence values to each ASV.
The &lt;code&gt;classify&lt;/code&gt; function may take a minute or so to process these
sequences, since it uses a computationally intensive dynamic programming
algorithm to find the likelihood values of each sequence given the
models at each node of the tree. The exception is when &lt;code&gt;ping&lt;/code&gt; is not
&lt;code&gt;FALSE&lt;/code&gt; and there is an exact match or high similarity&lt;br /&gt;
between the query sequence and at least one of the sequences in the
training dataset (e.g. &amp;gt;= 99% if &lt;code&gt;ping = 0.99&lt;/code&gt;). In this case the
function simply returns the common ancestor of the matching sequences
without a confidence score. To stay on the safe side, we will keep
&lt;code&gt;ping = 1&lt;/code&gt; (i.e. only sequences with 100% identity are considered
matches).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;classify&lt;/code&gt; function can also be run in parallel by setting the
&lt;code&gt;cores&lt;/code&gt; argument to 2 or more depending on the number available (setting
&lt;code&gt;cores = &amp;quot;autodetect&amp;quot;&lt;/code&gt; will automatically run on one less than the
number available). If choosing this option for the large COI classifier,
please ensure that there is at least 2 GB of available RAM per
processor. Classification times can vary, and depend on several factors
including the number of unique sequences in the dataset, the size of the
classifier, the length of the input sequences, the processing speed,
number of processors used, etc. The average time to ID COI sequences
using the classifier above is approximately 3 - 4 seconds per unique
sequence per processor. For example, a dataset containing 1000 unique
sequences would take around an hour to process on a single processor,
half an hour on two, and so on.&lt;/p&gt;

&lt;p&gt;In the following code we set &lt;code&gt;tabulize = FALSE&lt;/code&gt; (the default setting)
since the DADA2 output table already contains the sequence counts and we
are only classifying the unique sequence variants. In the case where a
list of sequences containing replicates is to be processed, users can
prefix the sequence names with their respective sample names, delimited
with an underscore (e.g. &amp;ldquo;sample001_sequence001&amp;rdquo;) and set
&lt;code&gt;tabulize = TRUE&lt;/code&gt;. In this case, the &lt;code&gt;classify&lt;/code&gt; function will
automatically count and dereplicate the sequences, producing an output
table with one column of sequence counts for each sample.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;longDF &amp;lt;- classify(x, classifier, threshold = 0.8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For DADA2 users, the ASV abundance table can now be transposed and
appended to the table of taxonomic information if required:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;longDF &amp;lt;- cbind(longDF, t(samoa))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- note newlines needed between html tags and code chunk --&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;representative&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;taxID&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;taxon&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;rank&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;score&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;kingdom&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;phylum&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;class&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;order&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;family&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;genus&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;species&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;OFU04A-100_S64&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;OFU04A-1_S13&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2806&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Florideophyceae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;class&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9981&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Florideophyceae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;156&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6379&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Chaetopterus&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;genus&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Metazoa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Annelida&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Polychaeta&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Spionida&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Chaetopteridae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Chaetopterus&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4496&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2806&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Florideophyceae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;class&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9989&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Florideophyceae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;28&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3267&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2172821&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Multicrustacea&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;superclass&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Metazoa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Arthropoda&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3203&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;131567&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;cellular organisms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no rank&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9952&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3024&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2806&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Florideophyceae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;class&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9981&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Florideophyceae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;20&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2409&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;39820&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nereididae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;family&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Metazoa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Annelida&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Polychaeta&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Phyllodocida&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nereididae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2379&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;116571&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Podoplea&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;superorder&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9995&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Metazoa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Arthropoda&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Hexanauplia&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2156&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;104&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2806&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Florideophyceae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;class&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9482&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Florideophyceae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2149&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;root&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no rank&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2091&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV11&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;115834&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Hesionidae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;family&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Metazoa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Annelida&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Polychaeta&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Phyllodocida&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Hesionidae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1905&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1443949&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Corallinophycidae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;subclass&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9910&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Florideophyceae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;87&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1757&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV13&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;33213&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Bilateria&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no rank&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Metazoa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;27&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1800&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV14&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;131567&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;cellular organisms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no rank&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9952&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1729&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV15&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2806&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Florideophyceae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;class&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9993&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Florideophyceae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1725&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ASV16&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;39820&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nereididae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;family&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Metazoa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Annelida&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Polychaeta&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Phyllodocida&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nereididae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1481&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;!--
The function produces a data frame with one row for each ASV
Assuming `ping` is not `FALSE`, query sequences that have 
exact or close matches in the training dataset 
(and hence bypass the recursive classification procedure)
are assigned a score of `NA`.
--&gt;

&lt;p&gt;Any sequences that return exact hits with at least one training sequence
(or near matches if &lt;code&gt;ping = 0.99&lt;/code&gt; or similar) are assigned a score of
&lt;code&gt;NA&lt;/code&gt;. For hybrid DNA/AA classifiers such as the COI version used above,
non-translatable sequences are also automatically assigned a score of
&lt;code&gt;NA&lt;/code&gt;, as is the case for ASV10 in the table above.&lt;/p&gt;

&lt;p&gt;For a more succinct output we can aggregate the table to only include
one row for each unique taxon as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;taxa &amp;lt;- aggregate(longDF[3:12], longDF[&amp;quot;taxID&amp;quot;], head, 1)
counts &amp;lt;- aggregate(longDF[13:ncol(longDF)], longDF[&amp;quot;taxID&amp;quot;], sum)
shortDF &amp;lt;- merge(taxa, counts, by = &amp;quot;taxID&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- note newlines needed between html tags and code chunk --&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;right&#34;&gt;taxID&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;taxon&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;rank&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;score&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;kingdom&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;phylum&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;class&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;order&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;family&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;genus&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;species&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;OFU04A-100_S64&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;OFU04A-1_S13&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;root&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no rank&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;NA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2091&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;2806&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Florideophyceae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;class&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9981&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Florideophyceae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;204&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;15150&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;6379&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Chaetopterus&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;genus&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Metazoa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Annelida&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Polychaeta&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Spionida&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Chaetopteridae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Chaetopterus&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4496&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;33213&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Bilateria&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no rank&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Metazoa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;27&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1800&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;39820&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nereididae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;family&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Metazoa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Annelida&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Polychaeta&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Phyllodocida&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nereididae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3860&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;115834&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Hesionidae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;family&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Metazoa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Annelida&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Polychaeta&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Phyllodocida&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Hesionidae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1905&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;116571&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Podoplea&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;superorder&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9995&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Metazoa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Arthropoda&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Hexanauplia&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2156&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;104&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;131567&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;cellular organisms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no rank&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9952&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4753&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;1443949&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Corallinophycidae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;subclass&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9910&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Florideophyceae&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;87&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1757&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;2172821&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Multicrustacea&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;superclass&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Metazoa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Arthropoda&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3203&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As shown in the above example, many of the sequences return fairly
uninformative taxon IDs (e.g. &amp;lsquo;cellular organisms&amp;rsquo;). This is a fairly
typical feature of eDNA datasets that can contain a large number of
novel sequences that are dissimilar to anything recorded in the
reference database(s). Note that query sequences with high similarity to
reference sequences can also occasionally produce uninformative
classifications due to inconclusive model comparison tests at top-level
nodes. This may be circumvented by reducing the &lt;code&gt;threshold&lt;/code&gt; parameter or
setting &lt;code&gt;decay = FALSE&lt;/code&gt;; however, users are advised against the
excessive relaxation of these parameters since it may increase the
chance of returning erroneous classifications (these tend to be very
rare when using the default values). Further testing and optimization
may help to address some of these best-practice considerations, and will
be a focus of future research.&lt;/p&gt;

&lt;p&gt;This introduction to the &lt;strong&gt;insect&lt;/strong&gt; package has outlined the steps
involved in taxonomic identification of amplicon sequence variants
(ASVs) using a pre-built classification tree. The next tutorial will
deal with downloading and curating a primer-specific local sequence
database and using it to build a classification tree.&lt;/p&gt;

&lt;p&gt;Please feel free to email the author directly with any feedback or
questions at shaunpwilkinson AT gmail DOT com. Bug reports can also be
directed to the &lt;a href=&#34;http://github.com/shaunpwilkinson/insect/issues&#34; target=&#34;_blank&#34;&gt;GitHub issues
page&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;This software was developed with funding from a Rutherford Foundation
Postdoctoral Research Fellowship from the Royal Society of New Zealand.
Unpublished COI data care of Molly Timmers (NOAA).&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;p&gt;Callahan,B.J. &lt;em&gt;et al.&lt;/em&gt; (2016) DADA2: High-resolution sample inference
from illumina amplicon data. &lt;em&gt;Nature Methods&lt;/em&gt;, &lt;strong&gt;13&lt;/strong&gt;, 581–583.&lt;/p&gt;

&lt;p&gt;Durbin,R. &lt;em&gt;et al.&lt;/em&gt; (1998) Biological Sequence Analysis: Probabilistic
Models of Proteins and Nucleic Acids. Cambridge University Press,
Cambridge.&lt;/p&gt;

&lt;p&gt;Johnson,J.B. and Omland,K.S. (2004) Model selection in ecology and
evolution. &lt;em&gt;Trends in Ecology and Evolution&lt;/em&gt;, &lt;strong&gt;19&lt;/strong&gt;, 101–108.&lt;/p&gt;

&lt;p&gt;Leray,M. &lt;em&gt;et al.&lt;/em&gt; (2013) A new versatile primer set targeting a short
fragment of the mitochondrial COI region for metabarcoding metazoan
diversity: application for characterizing coral reef fish gut contents.
&lt;em&gt;Frontiers in Zoology&lt;/em&gt;, &lt;strong&gt;10&lt;/strong&gt;, 34.&lt;/p&gt;

&lt;p&gt;Paradis,E. (2012) Analysis of Phylogenetics and Evolution with R. Second
Edition. Springer, New York.&lt;/p&gt;

&lt;p&gt;Paradis,E. &lt;em&gt;et al.&lt;/em&gt; (2004) APE: analyses of phylogenetics and evolution
in R language. &lt;em&gt;Bioinformatics&lt;/em&gt;, &lt;strong&gt;20&lt;/strong&gt;, 289–290.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Accurate supervised classification of environmental DNA</title>
      <link>/project/edna_classification/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/project/edna_classification/</guid>
      <description>&lt;p&gt;Environmental DNA (eDNA) meta-barcoding offers unprecidented insights into the ecology of biological communities, enabling comprehensive assessments of biodiversity from only trace amounts of genetic material. Yet several analytical challenges remain, particularly when incorporating robust statistical inference in the assignment of taxonomic identities. False discovery rates at low taxonomic ranks are often well above those generally considered acceptable in biology, leading to questionable conclusions being reported in the literature. In this project, we focus on developing new supervised machine-learning algorithms that incorporate full probabilistic models to identify the taxonomic sources of environmental DNA amplicon sequences. These models offer strict control of false discovery rates, and often improve recall (resolution/sensitivity), but at a cost of computational efficiency. With the increased availability of remote parallel computing services, a shift in focus toward precision and statistical interpretability favors the incorporation of full probabilistic models in the field of supervised taxonomic classification.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Diversity and species boundaries in Symbiodiniaceae</title>
      <link>/project/symbiodiniaceae_diversity/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/project/symbiodiniaceae_diversity/</guid>
      <description>&lt;p&gt;Global climate change is having devastating effects on the world’s coral reefs, with declines predicted to escalate sharply in the near future. Severe socio-economic impacts accompany reef degradation, including the loss of food security, coastal stability and tourism income for many of the world’s most vulnerable people. The newly-independent Indo-Pacific nation of Timor-Leste hosts one of the most diverse coral assemblage on Earth, with upwards of 500 coral species potentially inhabiting its reefs. Poorly equipped to carry out even basic assessments of reef diversity and health, the government of Timor-Leste is looking to to attract international researchers, providing a unique opportunity to advance our knowledge about coral diversity, ecology and evolution. We know that many coral species undergo hybridization; however little is known of their symbiotic algae, whose microscopic size and elusive life-cycle make them notoriously difficult to study. Direct evidence of sexual reproduction continues to evade researchers, but DNA evidence attests to its infrequent occurrence. If we can show that sexual reproduction occurs between members of different algal lineages, this would constitute a very important milestone for understanding how they evolve and how we might expedite their adaptation if and when the need arises. This project uses high-throughput DNA sequencing and new bioinformatic methods to explore the diversity of symbiotic algae in Timor Leste, and establish whether hybridization events have shaped the evolutionary history of this lineage.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Intragenomic variation in Symbiodiniaceae</title>
      <link>/project/symbiodiniaceae_igv/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/project/symbiodiniaceae_igv/</guid>
      <description>&lt;p&gt;The symbiosis between corals and dinoflagellate algae of the family Symbiodiniaceae is essential for the development and survival of coral reefs. Yet this fragile association is highly vulnerable to environmental disturbance. A coral’s ability to tolerate temperature stress depends on the fitness of its resident symbionts, whose thermal optima vary extensively between lineages. However, the in hospite population genetic structure of Symbiodiniaceae is poorly understood and mostly based on analysis of bulk DNA extracted from thousands to millions of cells. Using quantitative single-cell PCR, we enumerated DNA polymorphisms in the symbionts of the reef-building coral Pocillopora damicornis, and investigated the distribution of IGV Symbiodiniaceae at a variety of temporal and spatial scales. We also assessed the associations between IGV Symbiodiniaceae and coral host performance in both artificial and natural settings. We consider the evolutionary origins of prevalent IGV in Symbiodiniaceae, and its possible adaptive implications in a changing climate.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Taxonomic identification of environmental DNA with informatic sequence classification trees.</title>
      <link>/publication/peerj/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/publication/peerj/</guid>
      <description></description>
    </item>
    
    <item>
      <title>The &#39;aphid&#39; package for analysis with profile hidden Markov models</title>
      <link>/post/aphid-vignette/</link>
      <pubDate>Sat, 10 Nov 2018 12:00:00 +0000</pubDate>
      
      <guid>/post/aphid-vignette/</guid>
      <description>

&lt;hr /&gt;

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;aphid&lt;/strong&gt; is an R package for the development and application of hidden
Markov models and profile HMMs for biological sequence analysis. It
contains functions for multiple and pairwise sequence alignment, model
construction and parameter optimization, file import/export,
implementation of the forward, backward and Viterbi algorithms for
conditional sequence probabilities, tree-based sequence weighting, and
sequence simulation. The package has a wide variety of uses including
database searching, gene-finding and annotation, phylogenetic analysis
and sequence classification.&lt;/p&gt;

&lt;p&gt;Hidden Markov models (HMMs) underlie many of the most important tasks in
computational biology, including multiple sequence alignment, genome
annotation, and increasingly, sequence database searching. Originally
developed for speech recognition algorithms, their application to the
field of molecular biology has increased dramatically since advances in
computational capacity have enabled full probabilistic analysis in place
of heuristic approximations. Pioneering this transition are two groups
lead by Anders Krogh and Sean Eddy, whose respective software packages
&lt;a href=&#34;https://compbio.soe.ucsc.edu/sam.html&#34; target=&#34;_blank&#34;&gt;SAM&lt;/a&gt; and
&lt;a href=&#34;http://www.hmmer.org&#34; target=&#34;_blank&#34;&gt;HMMER&lt;/a&gt; have underpinned HMM-based bioinformatic
analysis for over two decades.&lt;/p&gt;

&lt;p&gt;Here, we present the &lt;strong&gt;aphid&lt;/strong&gt; package for analysis with profile hidden
Markov models in the R environment (R Core Team 2017). The package
contains functions for developing, plotting, importing and exporting
both standard and profile HMMs, as well as implementations of the
forward, backward and Viterbi algorithms for computing full and optimal
conditional sequence probabilities. The package also features a multiple
sequence alignment tool that produces high quality alignments &lt;em&gt;via&lt;/em&gt;
profile HMM training.&lt;/p&gt;

&lt;h3 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h3&gt;

&lt;p&gt;The &lt;strong&gt;aphid&lt;/strong&gt; package is designed to work in conjunction with the
&amp;ldquo;DNAbin&amp;rdquo; and &amp;ldquo;AAbin&amp;rdquo; object types produced using the &lt;strong&gt;ape&lt;/strong&gt; package
(Paradis, Claude, and Strimmer 2004; Paradis 2012). These object types,
in which sequences are represented in a bit-level coding scheme, are
preferred over standard character-type sequences for maximizing memory
and speed efficiency. While we recommend using &lt;strong&gt;ape&lt;/strong&gt; alongside
&lt;strong&gt;aphid&lt;/strong&gt;, it is not a requisite and as such is listed in the &amp;ldquo;Suggests&amp;rdquo;
rather than &amp;ldquo;Imports&amp;rdquo; section of the package description. Indeed, any
sequence of standard ASCII characters is supported, making &lt;strong&gt;aphid&lt;/strong&gt;
suitable for other applications outside of biological sequence analysis.
However, it should be noted that if DNA and/or amino acid sequences are
input as character vectors, the functions may not recognize the
ambiguity codes and therefore are not guaranteed to treat them
appropriately.&lt;/p&gt;

&lt;p&gt;To maximize speed, the low-level dynamic programming functions
(including the forward, backward, Viterbi, and maximum &lt;em&gt;a posteriori&lt;/em&gt;
algorithms) are written in C++ linking to the Rcpp package (Eddelbuettel
and Francois 2011). R versions of these functions are also maintained
for the purposes of debugging, experimentation and code interpretation.
This package also relies on the &lt;strong&gt;openssl&lt;/strong&gt; package (Ooms 2016) for
sequence and alignment comparisons using the MD5 hash algorithm.&lt;/p&gt;

&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;

&lt;p&gt;Two primary object classes, &amp;ldquo;HMM&amp;rdquo; (hidden Markov model) and &amp;ldquo;PHMM&amp;rdquo;
(profile hidden Markov model) are generated using the &lt;strong&gt;aphid&lt;/strong&gt;
functions deriveHMM and derivePHMM, respectively. These objects are
lists consisting of emission and transition probability matrices
(elements named &amp;ldquo;E&amp;rdquo; and &amp;ldquo;A&amp;rdquo;), and non-mandatory elements that may
include vectors of background emission and transition probabilities
(&amp;ldquo;qe&amp;rdquo; and &amp;ldquo;qa&amp;rdquo;, respectively) and other model metadata including &amp;ldquo;name&amp;rdquo;,
&amp;ldquo;description&amp;rdquo;, &amp;ldquo;size&amp;rdquo; (the number of modules in the model), and
&amp;ldquo;alphabet&amp;rdquo; (the set of symbols/residues emitted by the model). Objects
of class &amp;ldquo;DPA&amp;rdquo; (dynamic programming array) are also generated by the
Viterbi and forward/backward functions. These are predominantly created
for the purposes of succinct console-printing.&lt;/p&gt;

&lt;h3 id=&#34;functions&#34;&gt;Functions&lt;/h3&gt;

&lt;p&gt;HMMs and PHMMs are explained in more detail throughout the following
sections using &lt;strong&gt;aphid&lt;/strong&gt; package functions to demonstrate their utility.
The examples are borrowed from Durbin et al (1998), to which users are
encouraged to refer for a more in-depth explanation on the theory and
application of these models. Book chapter numbers are provided wherever
possible for ease of reference.&lt;/p&gt;

&lt;h4 id=&#34;hidden-markov-models&#34;&gt;Hidden Markov Models&lt;/h4&gt;

&lt;p&gt;A hidden Markov model is a hypothetical data-generating mechanism for a
sequence or set of sequences. It is depicted by a network of &lt;em&gt;states&lt;/em&gt;
each emitting symbols from a finite &lt;em&gt;alphabet&lt;/em&gt; according to a set of
&lt;em&gt;emission probabilities&lt;/em&gt;, whose values are specific to each state. The
states are traversed by an interconnecting set of &lt;em&gt;transition
probabilities&lt;/em&gt;, that include the probability of remaining in any given
state and those of transitioning to each of the other connected states.&lt;/p&gt;

&lt;p&gt;An example of a simple HMM is given in Durbin et al (1998) chapter 3.2.
An imaginary casino has two dice, one fair and one weighted. The fair
dice emits residues from the alphabet {1, 2, 3, 4, 5, 6} with equal
probabilities (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;6&lt;/sub&gt; for each residue). The probability of rolling a &amp;ldquo;6&amp;rdquo;
with the loaded dice is 0.5, while that of each of the other five
residues is 0.1. If the dealer has the fair dice, he may secretly switch
to the loaded dice with a probability of 0.05 after each roll, leaving a
95% chance that he will retain the fair dice. Alternatively, if he has
the loaded dice, he will switch back to the fair dice with a probability
of 0.1, or more likely, retain the loaded dice with a probability of
0.9.&lt;/p&gt;

&lt;p&gt;This example can be represented by a simple two-state hidden Markov
model. The following code manually builds and plots the &amp;ldquo;HMM&amp;rdquo; object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;library(&amp;quot;aphid&amp;quot;)
states &amp;lt;- c(&amp;quot;Begin&amp;quot;, &amp;quot;Fair&amp;quot;, &amp;quot;Loaded&amp;quot;)
residues &amp;lt;- paste(1:6)
### Define transition probability matrix A
A &amp;lt;- matrix(c(0, 0, 0, 0.99, 0.95, 0.1, 0.01, 0.05, 0.9), nrow = 3)
dimnames(A) &amp;lt;- list(from = states, to = states)
### Define emission probability matrix E
E &amp;lt;- matrix(c(rep(1/6, 6), rep(1/10, 5), 1/2), nrow = 2, byrow = TRUE)
dimnames(E) &amp;lt;- list(states = states[-1], residues = residues)
### Create the HMM object
x &amp;lt;- structure(list(A = A, E = E), class = &amp;quot;HMM&amp;quot;)
### Plot the model
plot(x, textexp = 1.5)
### Optionally add the transition probabilities as text
text(x = 0.02, y = 0.5, labels = &amp;quot;0.95&amp;quot;)
text(x = 0.51, y = 0.5, labels = &amp;quot;0.90&amp;quot;)
text(x = 0.5, y = 0.9, labels = &amp;quot;0.05&amp;quot;)
text(x = 0.5, y = 0.1, labels = &amp;quot;0.10&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/aphid-vignette_files/figure-markdown_strict/unnamed-chunk-2-1.png&#34; alt=&#34;&#34; /&gt;
&lt;strong&gt;Figure 1: A simple hidden Markov model for the dishonest casino
example.&lt;/strong&gt; The plot.HMM method depicts the transition probabilities as
weighted lines, and emission probabilities as horizontal grey bars. No
begin/end state is modeled in this example; however, this can be
achieved by entering non-zero probabilities in the first row and column
of the transition matrix and passing &amp;ldquo;begin = TRUE&amp;rdquo; to &lt;code&gt;plot.HMM&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For a sequence of observed rolls, we can establish the most likely
sequence of hidden states (including when the dice-switching most likely
occurred) using the Viterbi algorithm. In the example given in Durbin et
al (1998) chapter 3.2, the observed sequence of 300 rolls is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##  31511624644664424531132163116415213362514454363165 
##  66265666666511664531326512456366646316366631623264 
##  55236266666625151631222555441666566563564324364131 
##  51346514635341112641462625335636616366646623253441 
##  36616611632525624622552652522664353533362331216253 
##  64414432335163243633665562566662632666612355245242
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some observable clusters of 6&amp;rsquo;s suggest that the loaded dice made an
appearance at some stage, but when did the dice-switching occur? In the
following code, the Viterbi algorithm is used to find the most likely
sequence of hidden states given the model.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data(casino)
### The actual path is stored in the names attribute of the sequence
actual &amp;lt;- c(&amp;quot;F&amp;quot;, &amp;quot;L&amp;quot;)[match(names(casino), c(&amp;quot;Fair&amp;quot;, &amp;quot;Loaded&amp;quot;))]
### Find the predicted path
vit1 &amp;lt;- Viterbi(x, casino)
predicted &amp;lt;- c(&amp;quot;F&amp;quot;, &amp;quot;L&amp;quot;)[vit1$path + 1]
### Note the path element of the output Viterbi object is an integer vector
### the addition of 1 to the path converts from C/C++ to R&#39;s indexing style
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comparing the predicted path with the actual hidden sequence, the
Viterbi algorithm wasn&amp;rsquo;t far off:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##  Actual     FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFLLLLL 
##  Predicted  FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFLL 
## 
##  Actual     LLLLLLLLLLLLLLLLFFFFFFFFFFFFLLLLLLLLLLLLLLLLFFFLLL 
##  Predicted  LLLLLLLLLLLLLLLLFFFFFFFFFFFFLLLLLLLLLLLLLLLLLLLLLL 
## 
##  Actual     LLLLLLLLLLLFFFFFFFFFFFFFFFFFLLLLLLLLLLLLLFFFFFFFFF 
##  Predicted  LLLLLLLLLLLLFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 
## 
##  Actual     FFFFFFFFFFFFFFFFFFFFFFFFFFFFLLLLLLLLLLFFFFFFFFFFFF 
##  Predicted  FFFFFFFFFFFFFFFFFFFFFFFFFFFFFLLLLLLLLLLLLLFFFFFFFF 
## 
##  Actual     FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 
##  Predicted  FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 
## 
##  Actual     FFFFFFFFFFFFFFFFFLLLLLLLLLLLLLLLLLLLLLLFFFFFFFFFFF 
##  Predicted  FFFFFFFFFFFFFFFFFFFFLLLLLLLLLLLLLLLLLLLFFFFFFFFFFF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also calculate the full and posterior probabilities of the
sequence given the model using the &lt;code&gt;forward&lt;/code&gt; and/or &lt;code&gt;backward&lt;/code&gt;
algorithms:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;casino.post &amp;lt;- posterior(x, casino)
plot(1:300, seq(0, 1, length.out = 300), type = &amp;quot;n&amp;quot;, xlab = &amp;quot;Roll number&amp;quot;,
     ylab = &amp;quot;Posterior probability of dice being fair&amp;quot;)
starts &amp;lt;- which(c(&amp;quot;L&amp;quot;, actual) == &amp;quot;F&amp;quot; &amp;amp; c(actual, &amp;quot;F&amp;quot;) == &amp;quot;L&amp;quot;)
ends &amp;lt;- which(c(&amp;quot;F&amp;quot;, actual) == &amp;quot;L&amp;quot; &amp;amp; c(actual, &amp;quot;L&amp;quot;) == &amp;quot;F&amp;quot;) - 1
for(i in 1:6) rect(starts[i], 0, ends[i], 1, col = &amp;quot;grey&amp;quot;, border = NA)
lines(1:300, casino.post[1, ])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/aphid-vignette_files/figure-markdown_strict/unnamed-chunk-6-1.png&#34; alt=&#34;&#34; /&gt;
&lt;strong&gt;Figure 2: Posterior state probabilities for the 300 dice rolls.&lt;/strong&gt; The
line shows the posterior probability that the dice was fair at each
roll, while the grey rectangles show the actual periods for which the
loaded dice was being used. See Durbin et al (1998) chapter 3.2 for more
details.&lt;/p&gt;

&lt;h5 id=&#34;deriving-hmms-from-sequence-data&#34;&gt;Deriving HMMs from sequence data&lt;/h5&gt;

&lt;p&gt;The &lt;strong&gt;aphid&lt;/strong&gt; package features the function &lt;code&gt;deriveHMM&lt;/code&gt; for building an
HMM from a set of training sequences. The following code derives a
simple HMM from our single sequence of dice rolls with its known state
path (stored as the &amp;lsquo;names&amp;rsquo; attribute of the sequence).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;y &amp;lt;- deriveHMM(list(casino), logspace = FALSE)
plot(y, textexp = 1.5)

### Optionally add the transition probabilities as text
text(x = 0.02, y = 0.5, labels = round(y$A[&amp;quot;Fair&amp;quot;, &amp;quot;Fair&amp;quot;], 2))
text(x = 0.51, y = 0.5, labels = round(y$A[&amp;quot;Loaded&amp;quot;, &amp;quot;Loaded&amp;quot;], 2))
text(x = 0.5, y = 0.9, labels = round(y$A[&amp;quot;Fair&amp;quot;, &amp;quot;Loaded&amp;quot;], 2))
text(x = 0.5, y = 0.1, labels = round(y$A[&amp;quot;Loaded&amp;quot;, &amp;quot;Fair&amp;quot;], 2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/aphid-vignette_files/figure-markdown_strict/unnamed-chunk-7-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 3: A simple HMM derived from the sequence of 300 dice rolls.&lt;/strong&gt;
As in Fig. 1, transition probabilities are shown as weighted lines and
emission probabilities as horizontal grey bars.&lt;/p&gt;

&lt;p&gt;This appears to be fairly close to the actual model, despite the fact
that the training data consisted of just a single sequence. One would
typically derive an HMM from a list of many such sequences (hence why
the input argument is a list and not a vector) but this example is
simplified for clarity.&lt;/p&gt;

&lt;h4 id=&#34;profile-hidden-markov-models&#34;&gt;Profile Hidden Markov Models&lt;/h4&gt;

&lt;p&gt;A profile hidden Markov model is an extension of a standard HMM, where
the emission and transition probabilities are &lt;em&gt;position specific&lt;/em&gt;. That
is, they can change at each point along the sequence. These models
typically have many more parameters than their simpler HMM counterparts,
but can be very powerful for sequence analysis. The precursor to a
profile HMM is normally a multiple sequence alignment. Each column in
the alignment will often (but not always) be represented by one internal
position or &amp;ldquo;module&amp;rdquo; in the model, with each module consisting of three
states:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a silent &lt;em&gt;delete&lt;/em&gt; state that does not emit residues.&lt;/li&gt;
&lt;li&gt;an &lt;em&gt;insert&lt;/em&gt; state with emission probabilities reflecting the
background residue frequencies averaged over the entire alignment.&lt;/li&gt;
&lt;li&gt;a &lt;em&gt;match&lt;/em&gt; state with emission probabilities reflecting the residue
frequencies in the alignment column.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Figure 4 shows the three state types listed above as circles diamonds
and rectangles, respectively. The states are linked by transition
probabilities shown as weighted lines in the graph.&lt;/p&gt;

&lt;p&gt;Consider this small partial alignment of amino acid sequences from
Durbin et al (1998) chapter 5.3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data(globins)
globins

##            [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## HBA_HUMAN  &amp;quot;V&amp;quot;  &amp;quot;G&amp;quot;  &amp;quot;A&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;H&amp;quot;  &amp;quot;A&amp;quot;  &amp;quot;G&amp;quot;  &amp;quot;E&amp;quot;  &amp;quot;Y&amp;quot;  
## HBB_HUMAN  &amp;quot;V&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;N&amp;quot;  &amp;quot;V&amp;quot;  &amp;quot;D&amp;quot;  &amp;quot;E&amp;quot;  &amp;quot;V&amp;quot;  
## MYG_PHYCA  &amp;quot;V&amp;quot;  &amp;quot;E&amp;quot;  &amp;quot;A&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;D&amp;quot;  &amp;quot;V&amp;quot;  &amp;quot;A&amp;quot;  &amp;quot;G&amp;quot;  &amp;quot;H&amp;quot;  
## GLB3_CHITP &amp;quot;V&amp;quot;  &amp;quot;K&amp;quot;  &amp;quot;G&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;D&amp;quot;  
## GLB5_PETMA &amp;quot;V&amp;quot;  &amp;quot;Y&amp;quot;  &amp;quot;S&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;T&amp;quot;  &amp;quot;Y&amp;quot;  &amp;quot;E&amp;quot;  &amp;quot;T&amp;quot;  &amp;quot;S&amp;quot;  
## LGB2_LUPLU &amp;quot;F&amp;quot;  &amp;quot;N&amp;quot;  &amp;quot;A&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;-&amp;quot;  &amp;quot;N&amp;quot;  &amp;quot;I&amp;quot;  &amp;quot;P&amp;quot;  &amp;quot;K&amp;quot;  &amp;quot;H&amp;quot;  
## GLB1_GLYDI &amp;quot;I&amp;quot;  &amp;quot;A&amp;quot;  &amp;quot;G&amp;quot;  &amp;quot;A&amp;quot;  &amp;quot;D&amp;quot;  &amp;quot;N&amp;quot;  &amp;quot;G&amp;quot;  &amp;quot;A&amp;quot;  &amp;quot;G&amp;quot;  &amp;quot;V&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Position-specific patterns include a high probability of observing a &amp;ldquo;V&amp;rdquo;
at position 1 and an &amp;ldquo;A&amp;rdquo; or &amp;ldquo;G&amp;rdquo; at position 3. When tabulating the
frequencies it is also prudent to add pseudo-counts, since the absence
of a particular transition or emission type does not preclude the
possibility of it occurring in another (unobserved) sequence.
Pseudo-counts can be Laplacean (adds one of each emission and transition
type), background (adjusts the Laplacean pseudo-counts to reflect the
background frequencies derived from the entire alignment), or user
defined, which can include more complex pseudo-count schemes such as
Dirichlet mixtures (Durbin et al. 1998).&lt;br /&gt;
The default option for the derivePHMM function is &amp;ldquo;background&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The following code derives a profile HMM from the globin data and plots
the model:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;globins.PHMM &amp;lt;- derivePHMM(globins, residues = &amp;quot;AMINO&amp;quot;, seqweights = NULL)
plot(globins.PHMM)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/aphid-vignette_files/figure-markdown_strict/unnamed-chunk-9-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 4: Profile HMM derived from a partial globin sequence
alignment.&lt;/strong&gt; Match states are shown as rectangles, insert states as
diamonds, and delete states as circles. Grey horizontal bars represent
the emission probabilities for each residue in the alphabet (in this
case the amino acid alphabet) at each position in the model. Numbers in
the delete states are simply model module numbers, while those in the
insert states are the probabilities of remaining in the current insert
state at the next emission cycle. Lines are weighted and directed where
necessary to reflect the transition probabilities between states. The
large &amp;ldquo;B&amp;rdquo; and &amp;ldquo;E&amp;rdquo; labels represent are the silent begin and end states,
respectively.&lt;/p&gt;

&lt;p&gt;Note that there are only 8 internal modules (excluding the begin and end
states), while the alignment had 10 columns. The &lt;code&gt;derivePHMM&lt;/code&gt; function
decided (using the maximum &lt;em&gt;a posteriori&lt;/em&gt; algorithm) that there was not
enough residue information in columns 4 and 5 of the alignment to
warrant assigning them internal modules in the model. Instead, the last
sequence in the alignment (GLB1_GLYDI) was considered to have entered
the insert state at position 3 where it remained for two emission cycles
(emitting an &amp;ldquo;A&amp;rdquo; and a &amp;ldquo;D&amp;rdquo;) before transitioning to the match state in
module 4. We can show this by calculating the optimal path of that
sequence through the model, again using the Viterbi algorithm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;path &amp;lt;- Viterbi(globins.PHMM, globins[&amp;quot;GLB1_GLYDI&amp;quot;, ])$path
path

##  [1] 1 1 1 2 2 1 1 1 1 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;ldquo;path&amp;rdquo; element of the Viterbi object is an integer vector with
elements taking values 0 (&amp;ldquo;delete&amp;rdquo;), 1 (&amp;ldquo;match&amp;rdquo;) or 2 (&amp;ldquo;insert&amp;rdquo;). The
path can be expressed more intuitively as characters instead of indices
as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c(&amp;quot;D&amp;quot;, &amp;quot;M&amp;quot;, &amp;quot;I&amp;quot;)[path + 1]

##  [1] &amp;quot;M&amp;quot; &amp;quot;M&amp;quot; &amp;quot;M&amp;quot; &amp;quot;I&amp;quot; &amp;quot;I&amp;quot; &amp;quot;M&amp;quot; &amp;quot;M&amp;quot; &amp;quot;M&amp;quot; &amp;quot;M&amp;quot; &amp;quot;M&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the addition of 1 to each path element is simply to convert
from the C/C++ indexing style (which begins at 0) to R&amp;rsquo;s style.&lt;/p&gt;

&lt;p&gt;Sequences do not need to be aligned to produce a profile HMM. The
function &lt;code&gt;derivePHMM&lt;/code&gt; can optionally take a list of unaligned sequences,
in which case the longest sequence is used as a &amp;lsquo;seed&amp;rsquo; to create a
preliminary profile HMM, and the model is iteratively trained with the
sequence list using either the Baum Welch or Viterbi training algorithm
(see model training section below).&lt;/p&gt;

&lt;h5 id=&#34;file-i-o&#34;&gt;File I/O&lt;/h5&gt;

&lt;p&gt;Profile HMMs can be exported as text files in the HMMER v3 format
(&lt;a href=&#34;http://www.hmmer.org/&#34; target=&#34;_blank&#34;&gt;http://www.hmmer.org/&lt;/a&gt;) using the function &lt;code&gt;writePHMM&lt;/code&gt;. For example,
the small globin profile HMM can be exported by running
&lt;code&gt;writePHMM(globins.PHMM)&lt;/code&gt;. Similarly, a HMMER v3 text file can be parsed
into R as an object of class &amp;ldquo;PHMM&amp;rdquo; with the function &lt;code&gt;readPHMM&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;sequence-simulation&#34;&gt;Sequence Simulation&lt;/h5&gt;

&lt;p&gt;To simulate data with random variation, the &lt;strong&gt;aphid&lt;/strong&gt; package features
the function &lt;code&gt;generate&lt;/code&gt; with methods for both HMMs and PHMM objects.
Sequences are generated recursively using the transition and emission
probabilities from within the model. There are two compulsory arguments,
a model (object class &amp;ldquo;HMM&amp;rdquo; or &amp;ldquo;PHMM&amp;rdquo;) and the &amp;ldquo;size&amp;rdquo; argument, which
specifies the maximum length of the sequence (this prevent an overflow
situation that can occur if insert-insert transition probabilities are
relatively high). For example, the following code simulates a list of 10
random sequences from the small globin profile HMM:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sim &amp;lt;- list(length = 10)
set.seed(9999)
for(i in 1:10) sim[[i]] &amp;lt;- generate(globins.PHMM, size = 20)
sim

## $length
##   M   M   M   M   I   I   M   M   M   M 
## &amp;quot;N&amp;quot; &amp;quot;G&amp;quot; &amp;quot;T&amp;quot; &amp;quot;K&amp;quot; &amp;quot;K&amp;quot; &amp;quot;V&amp;quot; &amp;quot;H&amp;quot; &amp;quot;F&amp;quot; &amp;quot;G&amp;quot; &amp;quot;V&amp;quot; 
## 
## [[2]]
##   D   M   M   M   M   M   M   I   M 
## &amp;quot;-&amp;quot; &amp;quot;N&amp;quot; &amp;quot;V&amp;quot; &amp;quot;N&amp;quot; &amp;quot;G&amp;quot; &amp;quot;P&amp;quot; &amp;quot;G&amp;quot; &amp;quot;V&amp;quot; &amp;quot;L&amp;quot; 
## 
## [[3]]
##   M   D   D   M   M   M   M   M 
## &amp;quot;N&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;H&amp;quot; &amp;quot;Y&amp;quot; &amp;quot;E&amp;quot; &amp;quot;V&amp;quot; &amp;quot;V&amp;quot; 
## 
## [[4]]
##   M   M   M   M   M   M   M   M 
## &amp;quot;A&amp;quot; &amp;quot;W&amp;quot; &amp;quot;A&amp;quot; &amp;quot;N&amp;quot; &amp;quot;R&amp;quot; &amp;quot;P&amp;quot; &amp;quot;T&amp;quot; &amp;quot;G&amp;quot; 
## 
## [[5]]
##   M   M   M   M   M   M   M   M 
## &amp;quot;G&amp;quot; &amp;quot;V&amp;quot; &amp;quot;A&amp;quot; &amp;quot;V&amp;quot; &amp;quot;E&amp;quot; &amp;quot;D&amp;quot; &amp;quot;T&amp;quot; &amp;quot;V&amp;quot; 
## 
## [[6]]
##   M   M   M   M   M   M   M   M 
## &amp;quot;T&amp;quot; &amp;quot;G&amp;quot; &amp;quot;G&amp;quot; &amp;quot;Y&amp;quot; &amp;quot;A&amp;quot; &amp;quot;G&amp;quot; &amp;quot;S&amp;quot; &amp;quot;Y&amp;quot; 
## 
## [[7]]
##   M   M   M   M   M   M   I   M   M 
## &amp;quot;I&amp;quot; &amp;quot;W&amp;quot; &amp;quot;A&amp;quot; &amp;quot;T&amp;quot; &amp;quot;A&amp;quot; &amp;quot;P&amp;quot; &amp;quot;K&amp;quot; &amp;quot;Y&amp;quot; &amp;quot;P&amp;quot; 
## 
## [[8]]
##   M   M   M   M   M   M   M   M 
## &amp;quot;V&amp;quot; &amp;quot;N&amp;quot; &amp;quot;G&amp;quot; &amp;quot;D&amp;quot; &amp;quot;A&amp;quot; &amp;quot;G&amp;quot; &amp;quot;R&amp;quot; &amp;quot;Y&amp;quot; 
## 
## [[9]]
##   M   M   M   D   D   D   D   M 
## &amp;quot;V&amp;quot; &amp;quot;N&amp;quot; &amp;quot;W&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;H&amp;quot; 
## 
## [[10]]
##   D   D   D   M   M   M   M   M 
## &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;D&amp;quot; &amp;quot;K&amp;quot; &amp;quot;N&amp;quot; &amp;quot;A&amp;quot; &amp;quot;V&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the names attributes specify which state each residue was
emitted from, and gap symbols are emitted from delete states. If these
gaps are not required they can be removed as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sim &amp;lt;- lapply(sim, function(s) s[names(s) != &amp;quot;D&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;model-training&#34;&gt;Model Training&lt;/h5&gt;

&lt;p&gt;The &lt;strong&gt;aphid&lt;/strong&gt; package offers the function &lt;code&gt;train&lt;/code&gt; for optimizing model
parameters using either the Baum Welch or Viterbi training algorithm.
Both are iterative refinement algorithms; the former does not rely on a
multiple sequence alignment but is generally much slower than the
latter. The Viterbi training operation can be sped up further on
multi-CPU machines by specifying the &amp;ldquo;cores&amp;rdquo; argument for parallel
processing. The best choice of training algorithm will generally depend
on the nature of the problem and the computing resources available. For
more information see Durbin et al (1998) chapter 3.3 for standard HMMs
and chapter 6.5 for profile HMMs.&lt;/p&gt;

&lt;p&gt;The following code trains the small globin profile HMM with the
sequences simulated in the previous step using the Baum Welch algorithm.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;globins2.PHMM &amp;lt;- train(globins.PHMM, sim, method = &amp;quot;BaumWelch&amp;quot;, 
                       deltaLL = 0.01, seqweights = NULL)

## Iteration 1 log likelihood = -213.8818 
## Iteration 2 log likelihood = -187.5671 
## Iteration 3 log likelihood = -186.2003 
## Iteration 4 log likelihood = -185.4684 
## Iteration 5 log likelihood = -185.0501 
## Iteration 6 log likelihood = -184.8302 
## Iteration 7 log likelihood = -184.7419 
## Iteration 8 log likelihood = -184.7162 
## Iteration 9 log likelihood = -184.6974 
## Iteration 10 log likelihood = -184.6543 
## Iteration 11 log likelihood = -184.5744 
## Iteration 12 log likelihood = -184.4634 
## Iteration 13 log likelihood = -184.3386 
## Iteration 14 log likelihood = -184.2147 
## Iteration 15 log likelihood = -184.1037 
## Iteration 16 log likelihood = -184.0166 
## Iteration 17 log likelihood = -183.9569 
## Iteration 18 log likelihood = -183.9197 
## Iteration 19 log likelihood = -183.8976 
## Iteration 20 log likelihood = -183.8846 
## Iteration 21 log likelihood = -183.8769 
## Convergence threshold reached after 21 EM iterations
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As shown in the feedback (which can be switched off by setting &amp;ldquo;quiet =
TRUE&amp;rdquo;), this operation took 7 expectation-maximization iterations to
converge to the specified delta log-likelihood threshold of 0.01.&lt;/p&gt;

&lt;h2 id=&#34;sequence-alignment&#34;&gt;Sequence Alignment&lt;/h2&gt;

&lt;p&gt;The &lt;strong&gt;aphid&lt;/strong&gt; package can be used to produce high-quality multiple
sequence alignments using the iterative model training method outlined
above. The function &lt;code&gt;align&lt;/code&gt; takes as its primary argument a list of
sequences either as a &amp;ldquo;DNAbin&amp;rdquo; object, an &amp;ldquo;AAbin&amp;rdquo; object, or a list of
character sequences. An object of class &amp;ldquo;PHMM&amp;rdquo; can be passed to the
function as an optional secondary argument (&amp;ldquo;model&amp;rdquo;), in which case the
sequences are simply aligned to the model to produce the alignment
matrix. If &amp;ldquo;model&amp;rdquo; is NULL, a preliminary model is first derived using
the &amp;lsquo;seed&amp;rsquo; sequence method outlined above, after which the model is
trained using either the Baum Welch or Viterbi training algorithm
(specified &lt;em&gt;via&lt;/em&gt; the &amp;ldquo;method&amp;rdquo; argument). The sequences are then aligned
to the model in the usual fashion to produce the alignment. Note that if
only two sequences are present inthe input list, the &lt;code&gt;align&lt;/code&gt; function
will perform a pairwise alignment without a profile HMM (Smith-Waterman
or Needleman-Wunch alignment).&lt;/p&gt;

&lt;p&gt;In this final example, we will deconstruct the original globin alignment
and re-align the sequences using the original PHMM as a guide.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;globins &amp;lt;- unalign(globins)
align(globins, model = globins.PHMM, seqweights = NULL, residues = &amp;quot;AMINO&amp;quot;)

##            1   2   3   I   I   4   5   6   7   8  
## HBA_HUMAN  &amp;quot;V&amp;quot; &amp;quot;G&amp;quot; &amp;quot;A&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;H&amp;quot; &amp;quot;A&amp;quot; &amp;quot;G&amp;quot; &amp;quot;E&amp;quot; &amp;quot;Y&amp;quot;
## HBB_HUMAN  &amp;quot;V&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;N&amp;quot; &amp;quot;V&amp;quot; &amp;quot;D&amp;quot; &amp;quot;E&amp;quot; &amp;quot;V&amp;quot;
## MYG_PHYCA  &amp;quot;V&amp;quot; &amp;quot;E&amp;quot; &amp;quot;A&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;D&amp;quot; &amp;quot;V&amp;quot; &amp;quot;A&amp;quot; &amp;quot;G&amp;quot; &amp;quot;H&amp;quot;
## GLB3_CHITP &amp;quot;V&amp;quot; &amp;quot;K&amp;quot; &amp;quot;G&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;D&amp;quot;
## GLB5_PETMA &amp;quot;V&amp;quot; &amp;quot;Y&amp;quot; &amp;quot;S&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;T&amp;quot; &amp;quot;Y&amp;quot; &amp;quot;E&amp;quot; &amp;quot;T&amp;quot; &amp;quot;S&amp;quot;
## LGB2_LUPLU &amp;quot;F&amp;quot; &amp;quot;N&amp;quot; &amp;quot;A&amp;quot; &amp;quot;-&amp;quot; &amp;quot;-&amp;quot; &amp;quot;N&amp;quot; &amp;quot;I&amp;quot; &amp;quot;P&amp;quot; &amp;quot;K&amp;quot; &amp;quot;H&amp;quot;
## GLB1_GLYDI &amp;quot;I&amp;quot; &amp;quot;A&amp;quot; &amp;quot;G&amp;quot; &amp;quot;A&amp;quot; &amp;quot;D&amp;quot; &amp;quot;N&amp;quot; &amp;quot;G&amp;quot; &amp;quot;A&amp;quot; &amp;quot;G&amp;quot; &amp;quot;V&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the column names show the progressive positions along the
model and where residues were predicted to have been emitted by insert
states (e.g. the 4th and 5th residues of sequence 7).&lt;/p&gt;

&lt;h2 id=&#34;further-reading&#34;&gt;Further Reading&lt;/h2&gt;

&lt;p&gt;This package was written based on the algorithms described in Durbin et
al (1998). This book offers an in depth explanation of hidden Markov
models and profile HMMs for users of all levels of familiarity. Many of
the examples and datasets in the package are directly derived from the
text, which serves as a useful primer for this package. There are also
excellent resources available for those wishing to use profile HMMs
outside of the R environment. The aphid package maintains compatibility
with the HMMER software suite through the file input and output
functions readPHMM and writePHMM. Those interested are further
encouraged to check out the SAM software package, which also features a
comprehensive suite of functions and tutorials.&lt;/p&gt;

&lt;h2 id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;This software was developed at Victoria University of Wellington, NZ,
with funding from a Rutherford Foundation Postdoctoral Research
Fellowship award from the Royal Society of New Zealand.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;p&gt;Durbin, Richard, Sean Eddy, Anders Krogh, and Graeme Mitchison. 1998.
&lt;em&gt;Biological Sequence Analysis: Probabilistic Models of Proteins and
Nucleic Acids&lt;/em&gt;. Cambridge: Cambridge University Press.&lt;/p&gt;

&lt;p&gt;Eddelbuettel, Dirk, and Romain Francois. 2011. “Rcpp: seamless R and C++
integration.” &lt;em&gt;Journal of Statistical Software&lt;/em&gt; 40 (8): 1–18.
&lt;a href=&#34;http://www.jstatsoft.org/v40/i08/&#34; target=&#34;_blank&#34;&gt;http://www.jstatsoft.org/v40/i08/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ooms, Jeroen. 2016. &lt;em&gt;openssl: toolkit for encryption, signatures and
certificates based on OpenSSL&lt;/em&gt;. R package.
&lt;a href=&#34;https://cran.r-project.org/package=openssl&#34; target=&#34;_blank&#34;&gt;https://cran.r-project.org/package=openssl&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Paradis, Emmanuel. 2012. &lt;em&gt;Analysis of Phylogenetics and Evolution with
R&lt;/em&gt;. Second Edi. New York: Springer.&lt;/p&gt;

&lt;p&gt;Paradis, Emmanuel, Julien Claude, and Korbinian Strimmer. 2004. “APE:
analyses of phylogenetics and evolution in R language.” &lt;em&gt;Bioinformatics&lt;/em&gt;
20: 289–90.
doi:&lt;a href=&#34;https://doi.org/10.1093/bioinformatics/btg412&#34; target=&#34;_blank&#34;&gt;10.1093/bioinformatics/btg412&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;R Core Team. 2017. “R: A Language and Environment for Statistical
Computing.” Vienna, Austria: R Foundation for Statistical Computing.
&lt;a href=&#34;https://cran.r-project.org/&#34; target=&#34;_blank&#34;&gt;https://cran.r-project.org/&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>kmer: an R package for fast alignment-free clustering of biological sequences</title>
      <link>/post/kmer-vignette/</link>
      <pubDate>Fri, 06 Jul 2018 12:00:00 +0000</pubDate>
      
      <guid>/post/kmer-vignette/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Agglomerative clustering methods that rely on a multiple sequence
alignment and a matrix of pairwise distances can be computationally
infeasible for large DNA and amino acid datasets. Alternative k-mer
based clustering methods involve enumerating all &lt;em&gt;k&lt;/em&gt;-letter words in a
sequence through a sliding window of length &lt;em&gt;k&lt;/em&gt;. The
*n* × 4&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt; matrix of &lt;em&gt;k&lt;/em&gt;-mer counts (where &lt;em&gt;n&lt;/em&gt; is the number
of sequences) can then be used in place of a multiple sequence alignment
to calculate distances and/or build a phylogenetic tree. &lt;strong&gt;kmer&lt;/strong&gt; is an
R package for clustering large sequence datasets using fast
alignment-free &lt;em&gt;k&lt;/em&gt;-mer counting. This can be achieved with or without a
multiple sequence alignment, and with or without a matrix of pairwise
distances. These functions are detailed below with examples of their
utility.&lt;/p&gt;

&lt;h2 id=&#34;distance-matrix-computation&#34;&gt;Distance matrix computation&lt;/h2&gt;

&lt;p&gt;The function &lt;code&gt;kcount&lt;/code&gt; is used to enumerate all &lt;em&gt;k&lt;/em&gt;-mers within a
sequence or set of sequences, by sliding a window of length &lt;em&gt;k&lt;/em&gt; along
each sequence and counting the number of times each &lt;em&gt;k&lt;/em&gt;-mer appears (for
example, the 4&lt;sup&gt;3&lt;/sup&gt; = 64 possible DNA 3-mers: AAA, AAC, AAG, &amp;hellip;,
TTT). The &lt;code&gt;kdistance&lt;/code&gt; function can then compute an alignment-free
distance matrix, using a matrix of &lt;em&gt;k&lt;/em&gt;-mer counts to derive the pairwise
distances. The default distance metric used by &lt;code&gt;kdistance&lt;/code&gt; is the
&lt;em&gt;k&lt;/em&gt;-mer (&lt;em&gt;k&lt;/em&gt;-tuple) distance measure outlined in Edgar (2004). For two
DNA sequences &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, the fractional common &lt;em&gt;k&lt;/em&gt;-mer count over the
4&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt; possible words of length &lt;em&gt;k&lt;/em&gt; is calculated as:
$$F  = \sum\limits_{\tau}\frac{min (n_a(\tau), n_b (\tau))}{min (L_a , L_b ) - k + 1} \tag{1}$$&lt;/p&gt;

&lt;p&gt;where &lt;em&gt;τ&lt;/em&gt; represents each possible &lt;em&gt;k&lt;/em&gt;-mer, &lt;em&gt;n&lt;/em&gt;&lt;sub&gt;&lt;em&gt;a&lt;/em&gt;&lt;/sub&gt;(&lt;em&gt;τ&lt;/em&gt;) and
&lt;em&gt;n&lt;/em&gt;&lt;sub&gt;&lt;em&gt;b&lt;/em&gt;&lt;/sub&gt;(&lt;em&gt;τ&lt;/em&gt;) are the number of times &lt;em&gt;τ&lt;/em&gt; appears in each
sequence, &lt;em&gt;k&lt;/em&gt; is the &lt;em&gt;k&lt;/em&gt;-mer length and &lt;em&gt;L&lt;/em&gt; is the sequence length. The
pairwise distance between &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; is then calculated as:&lt;/p&gt;

&lt;p&gt;$$d = \frac{log(0.1 + F) - log(1.1)}{log(0.1)} \tag{2}$$&lt;/p&gt;

&lt;p&gt;For &lt;em&gt;n&lt;/em&gt; sequences, the &lt;code&gt;kdistance&lt;/code&gt; operation has time and memory
complexity &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;) and thus can become computationally
infeasible when the sequence set is large (e.g. &amp;gt; 10,000 sequences).
As such, the &lt;strong&gt;kmer&lt;/strong&gt; package also offers the function &lt;code&gt;mbed&lt;/code&gt;, that only
computes the distances from each sequence to a smaller (or equal) sized
subset of &amp;lsquo;seed&amp;rsquo; sequences (Blackshields &lt;em&gt;et al.&lt;/em&gt;, 2010). The default
behavior of the &lt;code&gt;mbed&lt;/code&gt; function is to select
*t* = (*l&lt;strong&gt;o&lt;/strong&gt;g*&lt;sub&gt;2&lt;/sub&gt;&lt;em&gt;n&lt;/em&gt;)&lt;sup&gt;2&lt;/sup&gt; seeds by clustering the
sequences (&lt;em&gt;k&lt;/em&gt;-means algorithm with *k* = &lt;em&gt;t&lt;/em&gt;), and selecting one
representative sequence from each cluster.&lt;/p&gt;

&lt;p&gt;DNA and amino acid sequences can be passed to &lt;code&gt;kcount&lt;/code&gt;, &lt;code&gt;kdistance&lt;/code&gt; and
&lt;code&gt;mbed&lt;/code&gt; either as a list of non-aligned sequences or a matrix of aligned
sequences, preferably in either the &amp;ldquo;DNAbin&amp;rdquo; or &amp;ldquo;AAbin&amp;rdquo; raw-byte format
(see the &lt;strong&gt;ape&lt;/strong&gt; package documentation for more information on these S3
classes). Character sequences are supported; however ambiguity codes may
not be recognized or treated appropriately, since raw ambiguities are
counted according to their underlying residue frequencies (e.g. the
5-mer &amp;ldquo;ACRGT&amp;rdquo; would contribute 0.5 to the tally for &amp;ldquo;ACAGT&amp;rdquo; and 0.5 to
that of &amp;ldquo;ACGGT&amp;rdquo;). This excludes the ambiguity code &amp;ldquo;N&amp;rdquo;, which is
ignored.&lt;/p&gt;

&lt;h4 id=&#34;example-1-compute-k-mer-distance-matrices-for-the-woodmouse-dataset&#34;&gt;Example 1: Compute k-mer distance matrices for the woodmouse dataset&lt;/h4&gt;

&lt;p&gt;The &lt;strong&gt;ape&lt;/strong&gt; R package (Paradis &lt;em&gt;et al.&lt;/em&gt;, 2004) contains a dataset of 15
aligned mitochondrial cytochrome &lt;em&gt;b&lt;/em&gt; gene DNA sequences from the
woodmouse &lt;em&gt;Apodemus sylvaticus&lt;/em&gt;, originally published in Michaux et al.
(2003). While the &lt;strong&gt;kmer&lt;/strong&gt; distance functions do not require sequences
to be aligned, this example will enable us to compare the performance of
the &lt;em&gt;k&lt;/em&gt;-mer distances with the alignment-dependent distances produced by
&lt;code&gt;ape::dist.dna&lt;/code&gt;. First, load the dataset and view the first few rows and
columns as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data(woodmouse, package = &amp;quot;ape&amp;quot;)
ape::as.character.DNAbin(woodmouse[1:5, 1:5])
#&amp;gt;         [,1] [,2] [,3] [,4] [,5]
#&amp;gt; No305   &amp;quot;n&amp;quot;  &amp;quot;t&amp;quot;  &amp;quot;t&amp;quot;  &amp;quot;c&amp;quot;  &amp;quot;g&amp;quot; 
#&amp;gt; No304   &amp;quot;a&amp;quot;  &amp;quot;t&amp;quot;  &amp;quot;t&amp;quot;  &amp;quot;c&amp;quot;  &amp;quot;g&amp;quot; 
#&amp;gt; No306   &amp;quot;a&amp;quot;  &amp;quot;t&amp;quot;  &amp;quot;t&amp;quot;  &amp;quot;c&amp;quot;  &amp;quot;g&amp;quot; 
#&amp;gt; No0906S &amp;quot;a&amp;quot;  &amp;quot;t&amp;quot;  &amp;quot;t&amp;quot;  &amp;quot;c&amp;quot;  &amp;quot;g&amp;quot; 
#&amp;gt; No0908S &amp;quot;a&amp;quot;  &amp;quot;t&amp;quot;  &amp;quot;t&amp;quot;  &amp;quot;c&amp;quot;  &amp;quot;g&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a semi-global (&amp;lsquo;glocal&amp;rsquo;) alignment featuring some incomplete
sequences, with unknown characters represented by the ambiguity code &amp;ldquo;n&amp;rdquo;
(e.g. No305). To avoid artificially inflating the distances between
these partial sequences and the others, we first trim the gappy ends by
subsetting the global alignment (note that the &lt;strong&gt;ape&lt;/strong&gt; function
&lt;code&gt;dist.dna&lt;/code&gt; also removes columns with ambiguity codes prior to distance
computation by default).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;woodmouse &amp;lt;- woodmouse[, apply(woodmouse, 2, function(v) !any(v == 0xf0))]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following code first computes the full *n* × &lt;em&gt;n&lt;/em&gt; distance matrix,
and then the embedded distances of each sequence to three randomly
selected seed sequences. In both cases the &lt;em&gt;k&lt;/em&gt;-mer size is set to 6.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;### Compute the full distance matrix and print the first few rows and columns
library(kmer)
woodmouse.kdist &amp;lt;- kdistance(woodmouse, k = 6)
print(as.matrix(woodmouse.kdist)[1:7, 1:7], digits = 2)
#&amp;gt;         No305  No304  No306 No0906S No0908S No0909S No0910S
#&amp;gt; No305   0.000 0.0322 0.0295   0.033   0.036   0.037   0.037
#&amp;gt; No304   0.032 0.0000 0.0051   0.020   0.022   0.032   0.023
#&amp;gt; No306   0.030 0.0051 0.0000   0.016   0.017   0.026   0.018
#&amp;gt; No0906S 0.033 0.0202 0.0162   0.000   0.024   0.033   0.014
#&amp;gt; No0908S 0.036 0.0224 0.0171   0.024   0.000   0.033   0.025
#&amp;gt; No0909S 0.037 0.0322 0.0264   0.033   0.033   0.000   0.034
#&amp;gt; No0910S 0.037 0.0233 0.0176   0.014   0.025   0.034   0.000

### Compute and print the embedded distance matrix
set.seed(999)
seeds &amp;lt;- sample(1:15, size = 3)
woodmouse.mbed &amp;lt;- mbed(woodmouse, seeds = seeds, k = 6)
print(woodmouse.mbed[,], digits = 2)
#&amp;gt;         No0909S No0913S  No304
#&amp;gt; No305    0.0368  0.0391 0.0322
#&amp;gt; No304    0.0322  0.0102 0.0000
#&amp;gt; No306    0.0264  0.0098 0.0051
#&amp;gt; No0906S  0.0332  0.0215 0.0202
#&amp;gt; No0908S  0.0332  0.0273 0.0224
#&amp;gt; No0909S  0.0000  0.0368 0.0322
#&amp;gt; No0910S  0.0341  0.0176 0.0233
#&amp;gt; No0912S  0.0242  0.0322 0.0273
#&amp;gt; No0913S  0.0368  0.0000 0.0102
#&amp;gt; No1103S  0.0171  0.0251 0.0202
#&amp;gt; No1007S  0.0046  0.0368 0.0322
#&amp;gt; No1114S  0.0451  0.0428 0.0373
#&amp;gt; No1202S  0.0345  0.0176 0.0233
#&amp;gt; No1206S  0.0304  0.0251 0.0202
#&amp;gt; No1208S  0.0046  0.0409 0.0359
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;example-2-alignment-free-tree-building&#34;&gt;Example 2: Alignment-free tree-building&lt;/h4&gt;

&lt;p&gt;In this example the alignment-free &lt;em&gt;k&lt;/em&gt;-mer distances calculated in
Example 1 are compared with the Kimura (1980) distance metric as
featured in the &lt;strong&gt;ape&lt;/strong&gt; package examples. The resulting neighbor-joining
trees are visualized using the &lt;code&gt;tanglegram&lt;/code&gt; function from the
&lt;strong&gt;dendextend&lt;/strong&gt; package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## compute pairwise distance matrices
dist1 &amp;lt;- ape::dist.dna(woodmouse, model = &amp;quot;K80&amp;quot;) 
dist2 &amp;lt;- kdistance(woodmouse, k = 7) 

## build neighbor-joining trees
phy1 &amp;lt;- ape::nj(dist1)
phy2 &amp;lt;- ape::nj(dist2)

## rearrange trees in ladderized fashion
phy1 &amp;lt;- ape::ladderize(phy1)
phy2 &amp;lt;- ape::ladderize(phy2)

## convert phylo objects to dendrograms
dnd1 &amp;lt;- as.dendrogram(phy1)
dnd2 &amp;lt;- as.dendrogram(phy2)

## plot the tanglegram
dndlist &amp;lt;- dendextend::dendlist(dnd1, dnd2)
dendextend::tanglegram(dndlist, fast = TRUE, margin_inner = 5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/kmer-vignette_files/figure-markdown_strict/unnamed-chunk-5-1.png&#34; width=&#34;700px&#34; style=&#34;display: block; margin: auto auto auto 0;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 1:&lt;/strong&gt; Tanglegram comparing distance measures for the woodmouse
sequences. Neighbor-joining trees derived from the alignment-dependent
(left) and alignment-free (right) distances show relatively congruent
fine-scale topologies, with the exception of the single sequence
No0908S.&lt;/p&gt;

&lt;h2 id=&#34;clustering-without-a-distance-matrix&#34;&gt;Clustering without a distance matrix&lt;/h2&gt;

&lt;p&gt;To avoid excessive time and memory use when building large trees (e.g.
&lt;em&gt;n&lt;/em&gt; &amp;gt; 10,000), the &lt;strong&gt;kmer&lt;/strong&gt; package features the function &lt;code&gt;cluster&lt;/code&gt;
for fast divisive clustering, free of both alignment and distance matrix
computation. This function first generates a matrix of &lt;em&gt;k&lt;/em&gt;-mer counts,
and then recursively partitions the matrix row-wise using successive
k-means clustering (&lt;em&gt;k&lt;/em&gt; = 2). While this method may not necessarily
reconstruct sufficiently accurate phylogenetic trees for taxonomic
purposes, it offers a fast and efficient means of producing large trees
for a variety of other applications such as tree-based sequence
weighting (e.g. Gerstein et al. (1994)), guide trees for progressive
multiple sequence alignment (e.g. Sievers et al. (2011)), and other
recursive operations such as classification and regression tree (CART)
learning.&lt;/p&gt;

&lt;p&gt;The package also features the function &lt;code&gt;otu&lt;/code&gt; for rapid clustering of
sequences into operational taxonomic units based on a genetic distance
(k-mer distance) threshold. This function performs a similar operation
to &lt;code&gt;cluster&lt;/code&gt; in that it recursively partitions a k-mer count matrix to
assign sequences to groups. However, the top-down splitting only
continues while the highest k-mer distance within each cluster is above
a defined threshold value. Rather than returning a dendrogram, &lt;code&gt;otu&lt;/code&gt;
returns a named integer vector of cluster membership, with asterisks
indicating the representative sequences within each cluster.&lt;/p&gt;

&lt;h4 id=&#34;example-3-otu-clustering-with-k-mers&#34;&gt;Example 3: OTU clustering with &lt;em&gt;k&lt;/em&gt;-mers&lt;/h4&gt;

&lt;p&gt;In this final example, the woodmouse dataset is clustered into
operational taxonomic units (OTUs) with a maximum within-cluster &lt;em&gt;k&lt;/em&gt;-mer
distance of 0.03 and with 20 random starts per k-means split
(recommended for improved accuracy).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set.seed(999)
woodmouse.OTUs &amp;lt;- otu(woodmouse, k = 5, threshold = 0.97, method = &amp;quot;farthest&amp;quot;, nstart = 20)
woodmouse.OTUs
#&amp;gt;   No305*    No304   No306*  No0906S  No0908S No0909S*  No0910S  No0912S 
#&amp;gt;        3        1        1        1        1        2        1        2 
#&amp;gt;  No0913S  No1103S  No1007S  No1114S  No1202S  No1206S  No1208S 
#&amp;gt;        1        2        2        3        1        1        2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function outputs a named integer vector of OTU membership, with
asterisks indicating the representative sequence from each cluster (i.e.
the most &amp;ldquo;central&amp;rdquo; sequence). In this case, three distinct OTUs were
found, with No305 and N01114S forming one cluster (3), No0909S, No0912S,
No1103S, No1007S and No1208S forming another (2) and the remainder
belonging to cluster 1 in concordance with the consensus topology of
Figure 1.&lt;/p&gt;

&lt;h2 id=&#34;concluding-remarks&#34;&gt;Concluding remarks&lt;/h2&gt;

&lt;p&gt;The &lt;strong&gt;kmer&lt;/strong&gt; package is released under the GPL-3 license. Please direct
bug reports to the GitHub issues page at
&lt;a href=&#34;http://github.com/shaunpwilkinson/kmer/issues&#34; target=&#34;_blank&#34;&gt;http://github.com/shaunpwilkinson/kmer/issues&lt;/a&gt;. Any feedback is greatly
appreciated.&lt;/p&gt;

&lt;h2 id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;This software was developed with funding from a Rutherford Foundation
Postdoctoral Research Fellowship from the Royal Society of New Zealand.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;p&gt;Blackshields,G. &lt;em&gt;et al.&lt;/em&gt; (2010) Sequence embedding for fast construction
of guide trees for multiple sequence alignment. &lt;em&gt;Algorithms for
Molecular Biology&lt;/em&gt;, &lt;strong&gt;5&lt;/strong&gt;, 21.&lt;/p&gt;

&lt;p&gt;Edgar,R.C. (2004) Local homology recognition and distance measures in
linear time using compressed amino acid alphabets. &lt;em&gt;Nucleic Acids
Research&lt;/em&gt;, &lt;strong&gt;32&lt;/strong&gt;, 380–385.&lt;/p&gt;

&lt;p&gt;Gerstein,M. &lt;em&gt;et al.&lt;/em&gt; (1994) Volume changes in protein evolution.
&lt;em&gt;Journal of Molecular Biology&lt;/em&gt;, &lt;strong&gt;236&lt;/strong&gt;, 1067–1078.&lt;/p&gt;

&lt;p&gt;Kimura,M. (1980) A simple method for estimating evolutionary rates of
base substitutions through comparative studies of nucleotide sequences.
&lt;em&gt;Journal of Molecular Evolution&lt;/em&gt;, &lt;strong&gt;16&lt;/strong&gt;, 111–120.&lt;/p&gt;

&lt;p&gt;Michaux,J.R. &lt;em&gt;et al.&lt;/em&gt; (2003) Mitochondrial phylogeography of the
woodmouse (Apodemus sylvaticus) in the Western Palearctic region.
&lt;em&gt;Molecular Ecology&lt;/em&gt;, &lt;strong&gt;12&lt;/strong&gt;, 685–697.&lt;/p&gt;

&lt;p&gt;Paradis,E. &lt;em&gt;et al.&lt;/em&gt; (2004) APE: analyses of phylogenetics and evolution
in R language. &lt;em&gt;Bioinformatics&lt;/em&gt;, &lt;strong&gt;20&lt;/strong&gt;, 289–290.&lt;/p&gt;

&lt;p&gt;Sievers,F. &lt;em&gt;et al.&lt;/em&gt; (2011) Fast, scalable generation of high-quality
protein multiple sequence alignments using Clustal Omega. &lt;em&gt;Molecular
Systems Biology&lt;/em&gt;, &lt;strong&gt;7&lt;/strong&gt;, 539.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>phylogram: dendrograms for evolutionary analysis</title>
      <link>/post/phylogram_blog/</link>
      <pubDate>Tue, 26 Jun 2018 12:00:00 +0000</pubDate>
      
      <guid>/post/phylogram_blog/</guid>
      <description>

&lt;hr /&gt;

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Evolutionary biologists are increasingly using R for building,
editing and visualizing phylogenetic trees.
The reproducible code-based workflow and comprehensive array of tools
available in packages such as &lt;a href=&#34;http://ape-package.ird.fr/&#34; target=&#34;_blank&#34;&gt;ape&lt;/a&gt;,
&lt;a href=&#34;https://github.com/KlausVigo/phangorn&#34; target=&#34;_blank&#34;&gt;phangorn&lt;/a&gt; and
&lt;a href=&#34;http://blog.phytools.org/&#34; target=&#34;_blank&#34;&gt;phytools&lt;/a&gt; make R an ideal platform for
phylogenetic analysis.
Yet the many of the different tree formats are not well integrated,
as pointed out in a recent
&lt;a href=&#34;https://ropensci.org/blog/2018/05/17/treeio/&#34; target=&#34;_blank&#34;&gt;post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The standard data structure for phylogenies in R is the &amp;ldquo;phylo&amp;rdquo;
object, a memory efficient, matrix-based tree representation.
However, non-biologists have tended to use a tree structure
called the &amp;ldquo;dendrogram&amp;rdquo;, which is a deeply nested list with
node properties defined by various attributes stored at each level.
While certainly not as memory efficient as the matrix-based format,
dendrograms are versatile and intuitive to manipulate, and hence
a large number of analytical and visualization functions exist
for this object type. A good example is the
&lt;a href=&#34;https://github.com/talgalili/dendextend&#34; target=&#34;_blank&#34;&gt;dendextend&lt;/a&gt; package,
which features an impressive range of options for editing dendrograms
and plotting publication-quality trees.&lt;/p&gt;

&lt;p&gt;To better integrate the phylo and dendrogram object types,
and hence increase the options available for both camps,
we developed the &lt;a href=&#34;https://github.com/ropensci/phylogram&#34; target=&#34;_blank&#34;&gt;phylogram&lt;/a&gt;
package, which is now a part of the &lt;a href=&#34;https://ropensci.org/&#34; target=&#34;_blank&#34;&gt;rOpenSci&lt;/a&gt;
project.
This small package features a handful of functions for tree conversion,
importing and exporting trees as parenthetic text, and manipulating
dendrograms for phylogenetic applications.
The phylogram package draws heavily on &lt;a href=&#34;http://ape-package.ird.fr/&#34; target=&#34;_blank&#34;&gt;ape&lt;/a&gt;,
but currently has no other non-standard dependencies.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;installation&#34;&gt;Installation&lt;/h3&gt;

&lt;p&gt;To download &lt;strong&gt;phylogram&lt;/strong&gt; from CRAN and load the package, run&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&amp;quot;phylogram&amp;quot;)
library(phylogram)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, to download the latest development version from &lt;a href=&#34;https://github.com/ropensci/phylogram&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;,
first ensure that the &lt;a href=&#34;https://github.com/r-lib/devtools&#34; target=&#34;_blank&#34;&gt;devtools&lt;/a&gt;,
&lt;a href=&#34;https://CRAN.R-project.org/package=kmer&#34; target=&#34;_blank&#34;&gt;kmer&lt;/a&gt;, and
&lt;a href=&#34;https://CRAN.R-project.org/package=dendextend&#34; target=&#34;_blank&#34;&gt;dendextend&lt;/a&gt;
packages are installed,
then run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;devtools::install_github(&amp;quot;ropensci/phylogram&amp;quot;, build_vignettes = TRUE) 
library(phylogram)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;tree-import-export&#34;&gt;Tree import/export&lt;/h3&gt;

&lt;p&gt;A wide variety of tree formats can be parsed as phylo objects using either the
well-optimized &lt;code&gt;ape::read.tree&lt;/code&gt; function
(for &lt;a href=&#34;http://evolution.genetics.washington.edu/phylip/newicktree.html&#34; target=&#34;_blank&#34;&gt;Newick&lt;/a&gt;
strings),
or the suite of specialized functions in the versatile
&lt;a href=&#34;https://ropensci.org/blog/2018/05/17/treeio/&#34; target=&#34;_blank&#34;&gt;treeio&lt;/a&gt; package.
To convert a phylo object to a dendrogram, the &lt;strong&gt;phylogram&lt;/strong&gt; package includes
the function &lt;code&gt;as.dendrogram&lt;/code&gt;, which retains node height attributes and can handle
non-ultrametric trees.&lt;/p&gt;

&lt;p&gt;For single-line parsing of dendrograms from Newick text,
the &lt;code&gt;read.dendrogram&lt;/code&gt; function wraps &lt;code&gt;ape::read.tree&lt;/code&gt;
and converts the resulting phylo class object to a dendrogram using &lt;code&gt;as.dendrogram&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Similarly, the functions &lt;code&gt;write.dendrogram&lt;/code&gt; and &lt;code&gt;as.phylo&lt;/code&gt; are used to
export dendrogram objects to parenthetic text and phylo objects, respectively.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;tree-editing&#34;&gt;Tree editing&lt;/h3&gt;

&lt;p&gt;The &lt;strong&gt;phylogram&lt;/strong&gt; package includes some new functions for manipulating
trees in dendrogram format.
Leaf nodes and internal branching nodes can be removed
using the function &lt;code&gt;prune&lt;/code&gt;, which identifies and
recursively deletes nodes based on pattern
matching of &amp;ldquo;label&amp;rdquo; attributes.
This is slower than &lt;code&gt;ape::drop.tip&lt;/code&gt;, but offers
the benefits of versatile string matching using regular expressions,
and the ability to remove inner nodes (and by extension all subnodes)
that feature matching &amp;ldquo;label&amp;rdquo; attributes.
To aid visualization, the function &lt;code&gt;ladder&lt;/code&gt; rearranges
the tree, sorting nodes by the number of members
(analogous to &lt;code&gt;ape::ladderize&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;For more controlled subsetting or when creating trees from scratch
(e.g. from a standard nested list), the function &lt;code&gt;remidpoint&lt;/code&gt;
recursively corrects all &amp;ldquo;midpoint&amp;rdquo;, &amp;ldquo;members&amp;rdquo; and &amp;ldquo;leaf&amp;rdquo; attributes.
Node heights can then be manipulated using either &lt;code&gt;reposition&lt;/code&gt;, which
scales the heights of all nodes in a tree by a given constant, or
&lt;code&gt;as.cladogram&lt;/code&gt;, which resets the &amp;ldquo;height&amp;rdquo; attributes of all terminal
leaf nodes to zero and progressively resets the heights of the inner nodes
in single incremental units.&lt;/p&gt;

&lt;p&gt;As an example, a simple three-leaf dendrogram can be created from
a nested list as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- list(1, list(2, 3))
## set class, midpoint, members and leaf attributes for each node
x &amp;lt;- remidpoint(x)
## set height attributes for each node
x &amp;lt;- as.cladogram(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A nice feature of the dendrogram object type that tree
editing operations can be carried out recursively
using fast inbuilt functions in the &amp;ldquo;apply&amp;rdquo; family such as &lt;code&gt;dendrapply&lt;/code&gt;
and &lt;code&gt;lapply&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, to label each leaf node of the tree alphabetically we can
create a simple labeling function and apply it to the tree nodes recursively using
&lt;code&gt;dendrapply&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;set_label &amp;lt;- function(node){
  if(is.leaf(node)) attr(node, &amp;quot;label&amp;quot;) &amp;lt;- LETTERS[node]
  return(node)
}
x &amp;lt;- dendrapply(x, set_label)
plot(x, horiz = TRUE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/unnamed-chunk-6-1.png&#34; width=&#34;1000px&#34; style=&#34;display: block; margin: auto auto auto 0;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;applications&#34;&gt;Applications&lt;/h3&gt;

&lt;p&gt;One application motivating bi-directional conversion between phylo and
dendrogram objects involves creating publication-quality &amp;lsquo;tanglegrams&amp;rsquo; using
the &lt;a href=&#34;https://github.com/talgalili/dendextend&#34; target=&#34;_blank&#34;&gt;dendextend&lt;/a&gt; package.
For example, to see how well the fast, alignment-free &lt;em&gt;k&lt;/em&gt;-mer distance
from the &lt;a href=&#34;https://CRAN.R-project.org/package=kmer&#34; target=&#34;_blank&#34;&gt;kmer&lt;/a&gt; package
performs in comparison to the standard Kimura 1980 distance measure,
we can create neighbor-joining trees using each method and plot them side by side
to check for incongruent nodes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;## load woodmouse data and remove columns with ambiguities
data(woodmouse, package = &amp;quot;ape&amp;quot;)
woodmouse &amp;lt;- woodmouse[, apply(woodmouse, 2, function(v) !any(v == 0xf0))]
## compute Kimura 1980 pairwise distance matrix
dist1 &amp;lt;- ape::dist.dna(woodmouse, model = &amp;quot;K80&amp;quot;)
## deconstruct alignment (not strictly necessary)
woodmouse &amp;lt;- as.list(as.data.frame(unclass(t(woodmouse))))
## compute kmer distance matrix 
dist2 &amp;lt;- kmer::kdistance(woodmouse, k = 7) 
## build and ladderize neighbor-joining trees
phy1 &amp;lt;- ape::nj(dist1)
phy2 &amp;lt;- ape::nj(dist2)
phy1 &amp;lt;- ape::ladderize(phy1)
phy2 &amp;lt;- ape::ladderize(phy2)
## convert phylo objects to dendrograms
dnd1 &amp;lt;- as.dendrogram(phy1)
dnd2 &amp;lt;- as.dendrogram(phy2)
## plot the tanglegram
dndlist &amp;lt;- dendextend::dendlist(dnd1, dnd2)
dendextend::tanglegram(dndlist, fast = TRUE, margin_inner = 5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/unnamed-chunk-7-1.png&#34; width=&#34;1000px&#34; style=&#34;display: block; margin: auto auto auto 0;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;In this case, the trees are congruent and branch lengths are similar.
However, if we reduce the &lt;em&gt;k&lt;/em&gt;-mer size from 7 to 6,
the accuracy of the tree reconstruction is affected:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;## compute kmer distance matrix 
dist3 &amp;lt;- kmer::kdistance(woodmouse, k = 6) 
phy3 &amp;lt;- ape::nj(dist3)
phy3 &amp;lt;- ape::ladderize(phy3)
dnd3 &amp;lt;- as.dendrogram(phy3)
dndlist &amp;lt;- dendextend::dendlist(dnd1, dnd3)
dendextend::tanglegram(dndlist, fast = TRUE, margin_inner = 5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/unnamed-chunk-8-1.png&#34; width=&#34;1000px&#34; style=&#34;display: block; margin: auto auto auto 0;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Hopefully users will find the package useful for a range of other applications,
and I look forward to receiving feedback from the community.
Thanks to &lt;a href=&#34;https://github.com/wcornwell&#34; target=&#34;_blank&#34;&gt;wcornwell&lt;/a&gt; and
&lt;a href=&#34;https://github.com/BenJWard&#34; target=&#34;_blank&#34;&gt;BenJWard&lt;/a&gt;
for reviewing the code and suggesting improvements,
and to &lt;a href=&#34;https://github.com/sckott&#34; target=&#34;_blank&#34;&gt;sckott&lt;/a&gt;
for handling the &lt;a href=&#34;https://github.com/ropensci&#34; target=&#34;_blank&#34;&gt;rOpenSci&lt;/a&gt; onboarding process.&lt;/p&gt;

&lt;p&gt;The phylogram package is available for download from
&lt;a href=&#34;https://github.com/ropensci/phylogram&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt; and
&lt;a href=&#34;https://CRAN.R-project.org/package=phylogram&#34; target=&#34;_blank&#34;&gt;CRAN&lt;/a&gt;,
and a summary of the package is published in the
&lt;a href=&#34;https://joss.theoj.org/papers/6773f7e7465b5068fc5654018c1a33b8&#34; target=&#34;_blank&#34;&gt;Journal of Open Source Software&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Intra-genomic variation in Symbiodinium correlates negatively with photosynthetic efficiency and coral host performance.</title>
      <link>/publication/core2018/</link>
      <pubDate>Thu, 24 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/publication/core2018/</guid>
      <description></description>
    </item>
    
    <item>
      <title>phylogram: an R package for phylogenetic analysis with nested lists</title>
      <link>/publication/joss/</link>
      <pubDate>Tue, 22 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/publication/joss/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Taxonomic identification of environmental DNA with informatic sequence classification trees</title>
      <link>/talk/wcmb/</link>
      <pubDate>Mon, 14 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/talk/wcmb/</guid>
      <description></description>
    </item>
    
    <item>
      <title>The distribution of intra-genomically variable dinoflagellate symbionts at Lord Howe Island, Australia.</title>
      <link>/publication/core2016/</link>
      <pubDate>Mon, 28 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/publication/core2016/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Intra-genomic variation in symbiotic dinoflagellates: recent divergence or recombination between lineages?</title>
      <link>/publication/bmc/</link>
      <pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>/publication/bmc/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
